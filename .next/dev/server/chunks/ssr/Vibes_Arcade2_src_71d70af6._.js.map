{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/jackmccordic/Desktop/Vibes/Arcade2/src/components/WalletStatus.tsx"],"sourcesContent":["\"use client\";\n\nimport { useEffect, useState } from \"react\";\nimport { formatEther } from \"viem\";\nimport {\n  useAccount,\n  useBalance,\n  useChainId,\n  useConnect,\n  useDisconnect,\n  usePublicClient\n} from \"wagmi\";\nimport { monadTestnet } from \"../lib/wagmi\";\n\nexport default function WalletStatus() {\n  const [mounted, setMounted] = useState(false);\n  const { address, isConnected } = useAccount();\n  const publicClient = usePublicClient();\n  const { data: balance, isLoading: isBalanceLoading, isError: isBalanceError } = useBalance({\n    address,\n    chainId: monadTestnet.id,\n    query: {\n      enabled: Boolean(address)\n    }\n  });\n  const chainId = useChainId();\n  const { connect, connectors, isPending } = useConnect();\n  const { disconnect } = useDisconnect();\n\n  const isCorrectChain = chainId === monadTestnet.id;\n  const [directBalance, setDirectBalance] = useState<string | null>(null);\n\n  useEffect(() => {\n    setMounted(true);\n  }, []);\n\n  useEffect(() => {\n    if (!mounted || !address || !publicClient || !isCorrectChain) {\n      setDirectBalance(null);\n      return;\n    }\n\n    let cancelled = false;\n    const loadBalance = async () => {\n      try {\n        const value = await publicClient.getBalance({ address });\n        if (!cancelled) {\n          setDirectBalance(formatEther(value));\n        }\n      } catch {\n        if (!cancelled) {\n          setDirectBalance(null);\n        }\n      }\n    };\n\n    loadBalance();\n    return () => {\n      cancelled = true;\n    };\n  }, [address, isCorrectChain, mounted, publicClient]);\n\n  if (!mounted) {\n    return (\n      <div className=\"card\">\n        <h3>Wallet</h3>\n        <p className=\"muted\">Loading wallet status...</p>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"card wallet-card\">\n      <h3>Wallet</h3>\n      {isConnected ? (\n        <>\n          <p className=\"muted\">\n            Connected: <span className=\"mono\">{address}</span>\n          </p>\n          <p className=\"muted\">\n            Balance:{\" \"}\n            <span className=\"mono\">\n              {isBalanceError\n                ? \"Unavailable\"\n                : isBalanceLoading && !directBalance\n                  ? \"Loading...\"\n                  : directBalance\n                    ? `${Number(directBalance).toFixed(4)} MON`\n                    : balance?.formatted\n                      ? `${Number(balance.formatted).toFixed(4)} ${balance.symbol || \"MON\"}`\n                      : \"0.0000 MON\"}\n            </span>\n          </p>\n          <p className={isCorrectChain ? \"success\" : \"error\"}>\n            {isCorrectChain ? \"Monad Testnet\" : `Wrong network (${chainId})`}\n          </p>\n          <button className=\"secondary\" onClick={() => disconnect()}>\n            Disconnect\n          </button>\n        </>\n      ) : (\n        <>\n          <p className=\"muted\">Connect your wallet to view challenges.</p>\n          <button\n            onClick={() => connect({ connector: connectors[0] })}\n            disabled={isPending}\n          >\n            Connect Wallet\n          </button>\n        </>\n      )}\n    </div>\n  );\n}\n"],"names":[],"mappings":";;;;;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQA;AAZA;;;;;;AAce,SAAS;IACtB,MAAM,CAAC,SAAS,WAAW,GAAG,IAAA,qOAAQ,EAAC;IACvC,MAAM,EAAE,OAAO,EAAE,WAAW,EAAE,GAAG,IAAA,+OAAU;IAC3C,MAAM,eAAe,IAAA,uMAAe;IACpC,MAAM,EAAE,MAAM,OAAO,EAAE,WAAW,gBAAgB,EAAE,SAAS,cAAc,EAAE,GAAG,IAAA,6LAAU,EAAC;QACzF;QACA,SAAS,uJAAY,CAAC,EAAE;QACxB,OAAO;YACL,SAAS,QAAQ;QACnB;IACF;IACA,MAAM,UAAU,IAAA,6LAAU;IAC1B,MAAM,EAAE,OAAO,EAAE,UAAU,EAAE,SAAS,EAAE,GAAG,IAAA,6LAAU;IACrD,MAAM,EAAE,UAAU,EAAE,GAAG,IAAA,mMAAa;IAEpC,MAAM,iBAAiB,YAAY,uJAAY,CAAC,EAAE;IAClD,MAAM,CAAC,eAAe,iBAAiB,GAAG,IAAA,qOAAQ,EAAgB;IAElE,IAAA,sOAAS,EAAC;QACR,WAAW;IACb,GAAG,EAAE;IAEL,IAAA,sOAAS,EAAC;QACR,IAAI,CAAC,WAAW,CAAC,WAAW,CAAC,gBAAgB,CAAC,gBAAgB;YAC5D,iBAAiB;YACjB;QACF;QAEA,IAAI,YAAY;QAChB,MAAM,cAAc;YAClB,IAAI;gBACF,MAAM,QAAQ,MAAM,aAAa,UAAU,CAAC;oBAAE;gBAAQ;gBACtD,IAAI,CAAC,WAAW;oBACd,iBAAiB,IAAA,+LAAW,EAAC;gBAC/B;YACF,EAAE,OAAM;gBACN,IAAI,CAAC,WAAW;oBACd,iBAAiB;gBACnB;YACF;QACF;QAEA;QACA,OAAO;YACL,YAAY;QACd;IACF,GAAG;QAAC;QAAS;QAAgB;QAAS;KAAa;IAEnD,IAAI,CAAC,SAAS;QACZ,qBACE,kQAAC;YAAI,WAAU;;8BACb,kQAAC;8BAAG;;;;;;8BACJ,kQAAC;oBAAE,WAAU;8BAAQ;;;;;;;;;;;;IAG3B;IAEA,qBACE,kQAAC;QAAI,WAAU;;0BACb,kQAAC;0BAAG;;;;;;YACH,4BACC;;kCACE,kQAAC;wBAAE,WAAU;;4BAAQ;0CACR,kQAAC;gCAAK,WAAU;0CAAQ;;;;;;;;;;;;kCAErC,kQAAC;wBAAE,WAAU;;4BAAQ;4BACV;0CACT,kQAAC;gCAAK,WAAU;0CACb,iBACG,gBACA,oBAAoB,CAAC,gBACnB,eACA,gBACE,GAAG,OAAO,eAAe,OAAO,CAAC,GAAG,IAAI,CAAC,GACzC,SAAS,YACP,GAAG,OAAO,QAAQ,SAAS,EAAE,OAAO,CAAC,GAAG,CAAC,EAAE,QAAQ,MAAM,IAAI,OAAO,GACpE;;;;;;;;;;;;kCAGd,kQAAC;wBAAE,WAAW,iBAAiB,YAAY;kCACxC,iBAAiB,kBAAkB,CAAC,eAAe,EAAE,QAAQ,CAAC,CAAC;;;;;;kCAElE,kQAAC;wBAAO,WAAU;wBAAY,SAAS,IAAM;kCAAc;;;;;;;6CAK7D;;kCACE,kQAAC;wBAAE,WAAU;kCAAQ;;;;;;kCACrB,kQAAC;wBACC,SAAS,IAAM,QAAQ;gCAAE,WAAW,UAAU,CAAC,EAAE;4BAAC;wBAClD,UAAU;kCACX;;;;;;;;;;;;;;AAOX"}},
    {"offset": {"line": 200, "column": 0}, "map": {"version":3,"sources":["file:///Users/jackmccordic/Desktop/Vibes/Arcade2/src/lib/contracts/arcadeEscrow.ts"],"sourcesContent":["import type { Address } from \"viem\";\n\nexport const arcadeEscrowAbi = [\n  {\n    inputs: [\n      { internalType: \"address\", name: \"opponent\", type: \"address\" },\n      { internalType: \"uint32\", name: \"gameId\", type: \"uint32\" },\n      { internalType: \"uint64\", name: \"acceptBy\", type: \"uint64\" },\n      { internalType: \"uint64\", name: \"resolveBy\", type: \"uint64\" },\n      { internalType: \"bytes32\", name: \"metaHash\", type: \"bytes32\" }\n    ],\n    name: \"createChallenge\",\n    outputs: [{ internalType: \"uint256\", name: \"matchId\", type: \"uint256\" }],\n    stateMutability: \"payable\",\n    type: \"function\"\n  },\n  {\n    inputs: [{ internalType: \"uint256\", name: \"matchId\", type: \"uint256\" }],\n    name: \"acceptChallenge\",\n    outputs: [],\n    stateMutability: \"payable\",\n    type: \"function\"\n  },\n  {\n    inputs: [{ internalType: \"uint256\", name: \"matchId\", type: \"uint256\" }],\n    name: \"refund\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [{ internalType: \"uint256\", name: \"matchId\", type: \"uint256\" }],\n    name: \"matches\",\n    outputs: [\n      { internalType: \"address\", name: \"creator\", type: \"address\" },\n      { internalType: \"address\", name: \"opponent\", type: \"address\" },\n      { internalType: \"uint96\", name: \"wager\", type: \"uint96\" },\n      { internalType: \"uint32\", name: \"gameId\", type: \"uint32\" },\n      { internalType: \"uint64\", name: \"createdAt\", type: \"uint64\" },\n      { internalType: \"uint64\", name: \"acceptBy\", type: \"uint64\" },\n      { internalType: \"uint64\", name: \"resolveBy\", type: \"uint64\" },\n      { internalType: \"uint8\", name: \"state\", type: \"uint8\" },\n      { internalType: \"address\", name: \"winner\", type: \"address\" },\n      { internalType: \"bytes32\", name: \"metaHash\", type: \"bytes32\" }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    anonymous: false,\n    inputs: [\n      { indexed: true, internalType: \"uint256\", name: \"matchId\", type: \"uint256\" },\n      { indexed: true, internalType: \"address\", name: \"creator\", type: \"address\" },\n      { indexed: true, internalType: \"address\", name: \"opponent\", type: \"address\" },\n      { indexed: false, internalType: \"uint256\", name: \"wager\", type: \"uint256\" },\n      { indexed: false, internalType: \"uint32\", name: \"gameId\", type: \"uint32\" },\n      { indexed: false, internalType: \"uint64\", name: \"acceptBy\", type: \"uint64\" },\n      { indexed: false, internalType: \"uint64\", name: \"resolveBy\", type: \"uint64\" },\n      { indexed: false, internalType: \"bytes32\", name: \"metaHash\", type: \"bytes32\" }\n    ],\n    name: \"ChallengeCreated\",\n    type: \"event\"\n  }\n] as const;\n\nexport const ESCROW_STATE = {\n  NONE: 0,\n  OPEN: 1,\n  ACCEPTED: 2,\n  FINALIZED: 3,\n  REFUNDED: 4,\n  CANCELED: 5\n} as const;\n\nexport function getArcadeEscrowAddress(): Address | null {\n  const value = process.env.NEXT_PUBLIC_ARCADE_ESCROW_ADDRESS;\n  if (!value) return null;\n  return value as Address;\n}\n"],"names":[],"mappings":";;;;;;;;AAEO,MAAM,kBAAkB;IAC7B;QACE,QAAQ;YACN;gBAAE,cAAc;gBAAW,MAAM;gBAAY,MAAM;YAAU;YAC7D;gBAAE,cAAc;gBAAU,MAAM;gBAAU,MAAM;YAAS;YACzD;gBAAE,cAAc;gBAAU,MAAM;gBAAY,MAAM;YAAS;YAC3D;gBAAE,cAAc;gBAAU,MAAM;gBAAa,MAAM;YAAS;YAC5D;gBAAE,cAAc;gBAAW,MAAM;gBAAY,MAAM;YAAU;SAC9D;QACD,MAAM;QACN,SAAS;YAAC;gBAAE,cAAc;gBAAW,MAAM;gBAAW,MAAM;YAAU;SAAE;QACxE,iBAAiB;QACjB,MAAM;IACR;IACA;QACE,QAAQ;YAAC;gBAAE,cAAc;gBAAW,MAAM;gBAAW,MAAM;YAAU;SAAE;QACvE,MAAM;QACN,SAAS,EAAE;QACX,iBAAiB;QACjB,MAAM;IACR;IACA;QACE,QAAQ;YAAC;gBAAE,cAAc;gBAAW,MAAM;gBAAW,MAAM;YAAU;SAAE;QACvE,MAAM;QACN,SAAS,EAAE;QACX,iBAAiB;QACjB,MAAM;IACR;IACA;QACE,QAAQ;YAAC;gBAAE,cAAc;gBAAW,MAAM;gBAAW,MAAM;YAAU;SAAE;QACvE,MAAM;QACN,SAAS;YACP;gBAAE,cAAc;gBAAW,MAAM;gBAAW,MAAM;YAAU;YAC5D;gBAAE,cAAc;gBAAW,MAAM;gBAAY,MAAM;YAAU;YAC7D;gBAAE,cAAc;gBAAU,MAAM;gBAAS,MAAM;YAAS;YACxD;gBAAE,cAAc;gBAAU,MAAM;gBAAU,MAAM;YAAS;YACzD;gBAAE,cAAc;gBAAU,MAAM;gBAAa,MAAM;YAAS;YAC5D;gBAAE,cAAc;gBAAU,MAAM;gBAAY,MAAM;YAAS;YAC3D;gBAAE,cAAc;gBAAU,MAAM;gBAAa,MAAM;YAAS;YAC5D;gBAAE,cAAc;gBAAS,MAAM;gBAAS,MAAM;YAAQ;YACtD;gBAAE,cAAc;gBAAW,MAAM;gBAAU,MAAM;YAAU;YAC3D;gBAAE,cAAc;gBAAW,MAAM;gBAAY,MAAM;YAAU;SAC9D;QACD,iBAAiB;QACjB,MAAM;IACR;IACA;QACE,WAAW;QACX,QAAQ;YACN;gBAAE,SAAS;gBAAM,cAAc;gBAAW,MAAM;gBAAW,MAAM;YAAU;YAC3E;gBAAE,SAAS;gBAAM,cAAc;gBAAW,MAAM;gBAAW,MAAM;YAAU;YAC3E;gBAAE,SAAS;gBAAM,cAAc;gBAAW,MAAM;gBAAY,MAAM;YAAU;YAC5E;gBAAE,SAAS;gBAAO,cAAc;gBAAW,MAAM;gBAAS,MAAM;YAAU;YAC1E;gBAAE,SAAS;gBAAO,cAAc;gBAAU,MAAM;gBAAU,MAAM;YAAS;YACzE;gBAAE,SAAS;gBAAO,cAAc;gBAAU,MAAM;gBAAY,MAAM;YAAS;YAC3E;gBAAE,SAAS;gBAAO,cAAc;gBAAU,MAAM;gBAAa,MAAM;YAAS;YAC5E;gBAAE,SAAS;gBAAO,cAAc;gBAAW,MAAM;gBAAY,MAAM;YAAU;SAC9E;QACD,MAAM;QACN,MAAM;IACR;CACD;AAEM,MAAM,eAAe;IAC1B,MAAM;IACN,MAAM;IACN,UAAU;IACV,WAAW;IACX,UAAU;IACV,UAAU;AACZ;AAEO,SAAS;IACd,MAAM;IACN;;IACA,OAAO;AACT"}},
    {"offset": {"line": 412, "column": 0}, "map": {"version":3,"sources":["file:///Users/jackmccordic/Desktop/Vibes/Arcade2/src/components/PendingChallenges.tsx"],"sourcesContent":["\"use client\";\n\nimport { useEffect, useMemo, useState } from \"react\";\nimport { Address, decodeEventLog, formatEther, parseAbiItem } from \"viem\";\nimport { useAccount, usePublicClient } from \"wagmi\";\nimport { arcadeEscrowAbi, ESCROW_STATE, getArcadeEscrowAddress } from \"../lib/contracts/arcadeEscrow\";\n\ntype PendingChallenge = {\n  matchId: bigint;\n  creator: Address;\n  opponent: Address;\n  wager: bigint;\n  acceptBy: bigint;\n  resolveBy: bigint;\n};\n\nconst MIN_WAGER_WEI = 10n ** 18n;\n\nexport default function PendingChallenges() {\n  const { address } = useAccount();\n  const publicClient = usePublicClient();\n  const escrowAddress = getArcadeEscrowAddress();\n  const [challenges, setChallenges] = useState<PendingChallenge[]>([]);\n  const [refreshKey, setRefreshKey] = useState(0);\n  const [status, setStatus] = useState(\"Idle\");\n  const [error, setError] = useState(\"\");\n  const [mounted, setMounted] = useState(false);\n\n  const isReady = Boolean(address && publicClient && escrowAddress && mounted);\n\n  useEffect(() => {\n    setMounted(true);\n  }, []);\n\n  useEffect(() => {\n    if (!isReady) {\n      setChallenges([]);\n      return;\n    }\n\n    let cancelled = false;\n\n    const load = async () => {\n      if (!publicClient || !escrowAddress || !address) return;\n      setStatus(\"Loading...\");\n      setError(\"\");\n\n      try {\n        const logs = await publicClient.getLogs({\n          address: escrowAddress,\n          event: parseAbiItem(\n            \"event ChallengeCreated(uint256 indexed matchId,address indexed creator,address indexed opponent,uint256 wager,uint32 gameId,uint64 acceptBy,uint64 resolveBy,bytes32 metaHash)\"\n          ),\n          fromBlock: 0n\n        });\n\n        const decoded = logs\n          .map((log) => {\n            const event = decodeEventLog({\n              abi: arcadeEscrowAbi,\n              data: log.data,\n              topics: log.topics\n            });\n            return {\n              matchId: event.args.matchId as bigint,\n              creator: event.args.creator as Address,\n              opponent: event.args.opponent as Address,\n              wager: event.args.wager as bigint,\n              acceptBy: event.args.acceptBy as bigint,\n              resolveBy: event.args.resolveBy as bigint\n            };\n          })\n          .filter((event) => event.opponent.toLowerCase() === address.toLowerCase());\n\n        const withState = await Promise.all(\n          decoded.map(async (event) => {\n            const match = (await publicClient.readContract({\n              address: escrowAddress,\n              abi: arcadeEscrowAbi,\n              functionName: \"matches\",\n              args: [event.matchId]\n            })) as readonly [\n              Address,\n              Address,\n              bigint,\n              number,\n              bigint,\n              bigint,\n              bigint,\n              number,\n              Address,\n              `0x${string}`\n            ];\n            return { event, state: match[7] };\n          })\n        );\n\n        const pending = withState\n          .filter((item) => item.state === ESCROW_STATE.OPEN && item.event.wager >= MIN_WAGER_WEI)\n          .map((item) => item.event)\n          .sort((a, b) => (a.wager > b.wager ? -1 : 1));\n\n        if (!cancelled) {\n          setChallenges(pending);\n          setStatus(\"Loaded\");\n        }\n      } catch (err: any) {\n        if (!cancelled) {\n          setError(err?.shortMessage || err?.message || \"Failed to load challenges\");\n          setStatus(\"Error\");\n        }\n      }\n    };\n\n    load();\n\n    return () => {\n      cancelled = true;\n    };\n  }, [address, escrowAddress, isReady, publicClient, refreshKey]);\n\n  const content = useMemo(() => {\n    if (!mounted) return \"Loading challenges...\";\n    if (!escrowAddress) return \"Missing NEXT_PUBLIC_ARCADE_ESCROW_ADDRESS\";\n    if (!address) return \"Connect wallet to view pending challenges.\";\n    if (error) return error;\n    if (status === \"Loading...\") return \"Loading challenges...\";\n    if (!challenges.length) return \"No pending challenges.\";\n    return null;\n  }, [address, challenges.length, error, escrowAddress, status]);\n\n  return (\n    <aside className=\"card\">\n      <div className=\"row\">\n        <h3>Pending Challenges</h3>\n        <button className=\"secondary\" onClick={() => setRefreshKey((prev) => prev + 1)}>\n          Refresh\n        </button>\n      </div>\n\n      {content ? <p className=\"muted\">{content}</p> : null}\n\n      {challenges.map((challenge) => (\n        <div key={challenge.matchId.toString()} className=\"challenge-item\">\n          <p className=\"mono\">Match #{challenge.matchId.toString()}</p>\n          <p className=\"muted\">From: {challenge.creator}</p>\n          <p>\n            Wager: <strong>{formatEther(challenge.wager)} MON</strong>\n          </p>\n        </div>\n      ))}\n    </aside>\n  );\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 624, "column": 0}, "map": {"version":3,"sources":["file:///Users/jackmccordic/Desktop/Vibes/Arcade2/src/lib/contracts/sudokuArena.ts"],"sourcesContent":["import type { Address } from \"viem\";\n\nexport const sudokuArenaAbi = [\n  {\n    inputs: [{ internalType: \"uint32\", name: \"gameId\", type: \"uint32\" }],\n    name: \"createPveMatch\",\n    outputs: [{ internalType: \"uint256\", name: \"matchId\", type: \"uint256\" }],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      { internalType: \"uint256\", name: \"escrowMatchId\", type: \"uint256\" },\n      { internalType: \"address\", name: \"opponent\", type: \"address\" },\n      { internalType: \"uint32\", name: \"gameId\", type: \"uint32\" },\n      { internalType: \"uint64\", name: \"acceptBy\", type: \"uint64\" },\n      { internalType: \"uint64\", name: \"resolveBy\", type: \"uint64\" }\n    ],\n    name: \"createPvpMatch\",\n    outputs: [{ internalType: \"uint256\", name: \"matchId\", type: \"uint256\" }],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      { internalType: \"uint256\", name: \"matchId\", type: \"uint256\" },\n      { internalType: \"uint8\", name: \"row\", type: \"uint8\" },\n      { internalType: \"uint8\", name: \"col\", type: \"uint8\" },\n      { internalType: \"uint8\", name: \"value\", type: \"uint8\" }\n    ],\n    name: \"submitMove\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      { internalType: \"uint256\", name: \"matchId\", type: \"uint256\" },\n      { internalType: \"address\", name: \"player\", type: \"address\" },\n      { internalType: \"uint8\", name: \"row\", type: \"uint8\" },\n      { internalType: \"uint8\", name: \"col\", type: \"uint8\" },\n      { internalType: \"uint8\", name: \"value\", type: \"uint8\" }\n    ],\n    name: \"submitMoveFor\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [{ internalType: \"uint256\", name: \"matchId\", type: \"uint256\" }],\n    name: \"matches\",\n    outputs: [\n      { internalType: \"address\", name: \"creator\", type: \"address\" },\n      { internalType: \"address\", name: \"opponent\", type: \"address\" },\n      { internalType: \"bool\", name: \"isPvp\", type: \"bool\" },\n      { internalType: \"uint8\", name: \"state\", type: \"uint8\" },\n      { internalType: \"uint64\", name: \"createdAt\", type: \"uint64\" },\n      { internalType: \"uint64\", name: \"acceptBy\", type: \"uint64\" },\n      { internalType: \"uint64\", name: \"resolveBy\", type: \"uint64\" },\n      { internalType: \"uint32\", name: \"gameId\", type: \"uint32\" },\n      { internalType: \"uint256\", name: \"startBlock\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"creatorFinishBlock\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"opponentFinishBlock\", type: \"uint256\" },\n      { internalType: \"uint8\", name: \"puzzleIndex\", type: \"uint8\" },\n      { internalType: \"bytes32\", name: \"puzzleHash\", type: \"bytes32\" }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [{ internalType: \"uint8\", name: \"index\", type: \"uint8\" }],\n    name: \"getPackedPuzzle\",\n    outputs: [{ internalType: \"bytes\", name: \"\", type: \"bytes\" }],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      { internalType: \"uint256\", name: \"matchId\", type: \"uint256\" },\n      { internalType: \"uint8\", name: \"row\", type: \"uint8\" },\n      { internalType: \"uint8\", name: \"col\", type: \"uint8\" }\n    ],\n    name: \"getCell\",\n    outputs: [{ internalType: \"uint8\", name: \"\", type: \"uint8\" }],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    anonymous: false,\n    inputs: [\n      { indexed: true, internalType: \"uint256\", name: \"matchId\", type: \"uint256\" },\n      { indexed: true, internalType: \"address\", name: \"creator\", type: \"address\" },\n      { indexed: true, internalType: \"address\", name: \"opponent\", type: \"address\" },\n      { indexed: false, internalType: \"bool\", name: \"isPvp\", type: \"bool\" },\n      { indexed: false, internalType: \"uint32\", name: \"gameId\", type: \"uint32\" },\n      { indexed: false, internalType: \"uint64\", name: \"acceptBy\", type: \"uint64\" },\n      { indexed: false, internalType: \"uint64\", name: \"resolveBy\", type: \"uint64\" },\n      { indexed: false, internalType: \"uint8\", name: \"puzzleIndex\", type: \"uint8\" },\n      { indexed: false, internalType: \"bytes32\", name: \"puzzleHash\", type: \"bytes32\" }\n    ],\n    name: \"MatchCreated\",\n    type: \"event\"\n  },\n  {\n    inputs: [],\n    name: \"nextMatchId\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\"\n  }\n] as const;\n\nexport function getSudokuArenaAddress(): Address | null {\n  const value = process.env.NEXT_PUBLIC_SUDOKU_ARENA_ADDRESS;\n  if (!value) return null;\n  return value as Address;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 962, "column": 0}, "map": {"version":3,"sources":["file:///Users/jackmccordic/Desktop/Vibes/Arcade2/src/components/SudokuGame.tsx"],"sourcesContent":["\"use client\";\n\nimport { useEffect, useMemo, useState } from \"react\";\nimport { Address, decodeEventLog, Hex } from \"viem\";\nimport {\n  useAccount,\n  useChainId,\n  usePublicClient,\n  useSignMessage,\n  useSwitchChain,\n  useWaitForTransactionReceipt,\n  useWriteContract\n} from \"wagmi\";\nimport { sudokuArenaAbi, getSudokuArenaAddress } from \"../lib/contracts/sudokuArena\";\nimport { monadTestnet } from \"../lib/wagmi\";\n\ntype PendingKey = `${number}-${number}`;\n\nconst emptyGrid = () => Array.from({ length: 9 }, () => Array(9).fill(0));\n\nfunction unpackPuzzle(packed: Hex): number[][] {\n  const bytes = Array.from(Buffer.from(packed.slice(2), \"hex\"));\n  const flat: number[] = [];\n  for (let i = 0; i < 81; i += 1) {\n    const byte = bytes[Math.floor(i / 2)] || 0;\n    const value = i % 2 === 0 ? byte >> 4 : byte & 0x0f;\n    flat.push(value);\n  }\n  const grid: number[][] = [];\n  for (let r = 0; r < 9; r += 1) {\n    grid.push(flat.slice(r * 9, r * 9 + 9));\n  }\n  return grid;\n}\n\nexport default function SudokuGame() {\n  const { address } = useAccount();\n  const chainId = useChainId();\n  const { switchChain } = useSwitchChain();\n  const publicClient = usePublicClient();\n  const [matchIdInput, setMatchIdInput] = useState(\"0\");\n  const [matchId, setMatchId] = useState<number | null>(null);\n  const [grid, setGrid] = useState<number[][]>(() => emptyGrid());\n  const [givens, setGivens] = useState<number[][]>(() => emptyGrid());\n  const [pendingCells, setPendingCells] = useState<Set<PendingKey>>(new Set());\n  const [status, setStatus] = useState(\"\");\n  const [error, setError] = useState(\"\");\n  const [txHash, setTxHash] = useState<`0x${string}` | null>(null);\n  const [mounted, setMounted] = useState(false);\n  const [selectedCell, setSelectedCell] = useState<{ row: number; col: number } | null>(\n    null\n  );\n  const [selectedValue, setSelectedValue] = useState(0);\n  const [useRelayer, setUseRelayer] = useState(true);\n  const [relayerSession, setRelayerSession] = useState<{\n    expiresAt: number;\n    signature: `0x${string}`;\n  } | null>(null);\n\n  const { writeContractAsync } = useWriteContract();\n  const { signMessageAsync } = useSignMessage();\n  const { isLoading: isConfirming } = useWaitForTransactionReceipt({\n    hash: txHash || undefined\n  });\n\n  const arenaAddress = getSudokuArenaAddress();\n  const isMonad = chainId === monadTestnet.id;\n  const canUseArena = Boolean(arenaAddress && isMonad);\n\n  const canSubmit = useMemo(() => {\n    return Boolean(canUseArena && matchId && matchId > 0);\n  }, [canUseArena, matchId]);\n\n  useEffect(() => {\n    if (!mounted) return;\n    const stored = localStorage.getItem(\"arcade2-relayer-session\");\n    if (!stored) return;\n    try {\n      const parsed = JSON.parse(stored) as { expiresAt: number; signature: `0x${string}` };\n      if (Date.now() < parsed.expiresAt) {\n        setRelayerSession(parsed);\n      }\n    } catch {\n      localStorage.removeItem(\"arcade2-relayer-session\");\n    }\n  }, [mounted]);\n\n  const invalidCells = useMemo(() => {\n    const next = new Set<string>();\n\n    const markInvalid = (row: number, col: number) => {\n      next.add(`${row}-${col}`);\n    };\n\n    for (let r = 0; r < 9; r += 1) {\n      for (let c = 0; c < 9; c += 1) {\n        const value = grid[r][c];\n        if (value === 0) continue;\n\n        for (let cc = 0; cc < 9; cc += 1) {\n          if (cc !== c && grid[r][cc] === value) {\n            markInvalid(r, c);\n            markInvalid(r, cc);\n          }\n        }\n\n        for (let rr = 0; rr < 9; rr += 1) {\n          if (rr !== r && grid[rr][c] === value) {\n            markInvalid(r, c);\n            markInvalid(rr, c);\n          }\n        }\n\n        const boxRow = Math.floor(r / 3) * 3;\n        const boxCol = Math.floor(c / 3) * 3;\n        for (let rr = boxRow; rr < boxRow + 3; rr += 1) {\n          for (let cc = boxCol; cc < boxCol + 3; cc += 1) {\n            if ((rr !== r || cc !== c) && grid[rr][cc] === value) {\n              markInvalid(r, c);\n              markInvalid(rr, cc);\n            }\n          }\n        }\n      }\n    }\n\n    return next;\n  }, [grid]);\n\n  const isComplete = useMemo(() => {\n    if (grid.some((row) => row.some((value) => value === 0))) return false;\n    return invalidCells.size === 0;\n  }, [grid, invalidCells.size]);\n\n  const isConfirmed = useMemo(() => {\n    return isComplete && pendingCells.size === 0 && !isConfirming;\n  }, [isComplete, pendingCells.size, isConfirming]);\n\n  useEffect(() => {\n    if (txHash && !isConfirming) {\n      setStatus(\"Move confirmed.\");\n    }\n  }, [txHash, isConfirming]);\n\n  useEffect(() => {\n    setMounted(true);\n  }, []);\n\n  useEffect(() => {\n    if (!publicClient || !arenaAddress || !matchId || matchId <= 0) {\n      setGrid(emptyGrid());\n      setGivens(emptyGrid());\n      return;\n    }\n\n    let cancelled = false;\n\n    const load = async () => {\n      try {\n        setStatus(\"Loading puzzle...\");\n        const match = (await publicClient.readContract({\n          address: arenaAddress,\n          abi: sudokuArenaAbi,\n          functionName: \"matches\",\n          args: [BigInt(matchId)]\n        })) as readonly [\n          Address,\n          Address,\n          boolean,\n          number,\n          bigint,\n          bigint,\n          bigint,\n          number,\n          bigint,\n          bigint,\n          bigint,\n          number,\n          `0x${string}`\n        ];\n\n        const puzzleIndex = match[11];\n        const packed = (await publicClient.readContract({\n          address: arenaAddress,\n          abi: sudokuArenaAbi,\n          functionName: \"getPackedPuzzle\",\n          args: [puzzleIndex]\n        })) as Hex;\n\n        const decoded = unpackPuzzle(packed);\n        if (!cancelled) {\n          setGivens(decoded);\n          setGrid(decoded.map((row) => row.map((value) => value)));\n          setStatus(\"Puzzle loaded\");\n        }\n      } catch (err: any) {\n        if (!cancelled) {\n          setError(err?.shortMessage || err?.message || \"Failed to load puzzle\");\n          setStatus(\"\");\n        }\n      }\n    };\n\n    load();\n\n    return () => {\n      cancelled = true;\n    };\n  }, [arenaAddress, matchId, publicClient]);\n\n  const handleCreatePve = async () => {\n    if (!arenaAddress) {\n      setError(\"Missing NEXT_PUBLIC_SUDOKU_ARENA_ADDRESS\");\n      return;\n    }\n    if (!isMonad) {\n      setError(\"Switch to Monad Testnet to create a match\");\n      return;\n    }\n    setError(\"\");\n    setStatus(\"\");\n    setTxHash(null);\n\n    try {\n      setStatus(\"Creating PvE match...\");\n      const hash = await writeContractAsync({\n        abi: sudokuArenaAbi,\n        address: arenaAddress,\n        chainId: monadTestnet.id,\n        functionName: \"createPveMatch\",\n        args: [1]\n      });\n      setTxHash(hash);\n      setStatus(\"Waiting for match creation...\");\n\n      await publicClient?.waitForTransactionReceipt({ hash });\n\n      let createdId: number | null = null;\n      const receipt = await publicClient?.getTransactionReceipt({ hash });\n      const matchLog = receipt?.logs.find(\n        (l) => l.address.toLowerCase() === arenaAddress.toLowerCase()\n      );\n      if (matchLog) {\n        const decoded = decodeEventLog({\n          abi: sudokuArenaAbi,\n          data: matchLog.data,\n          topics: matchLog.topics\n        });\n        if (decoded.eventName === \"MatchCreated\") {\n          createdId = Number(decoded.args.matchId);\n        }\n      }\n\n      if (!createdId && publicClient) {\n        const nextId = (await publicClient.readContract({\n          address: arenaAddress,\n          abi: sudokuArenaAbi,\n          functionName: \"nextMatchId\"\n        })) as bigint;\n        createdId = Number(nextId);\n      }\n\n      if (createdId) {\n        setMatchId(createdId);\n        setMatchIdInput(String(createdId));\n        setStatus(`Match #${createdId} ready`);\n      } else {\n        setStatus(\"Match created, but could not read match id\");\n      }\n    } catch (err: any) {\n      setError(err?.shortMessage || err?.message || \"Match creation failed\");\n      setStatus(\"\");\n    }\n  };\n\n  const handleLoadMatch = () => {\n    const id = Number(matchIdInput);\n    if (!Number.isInteger(id) || id <= 0) {\n      setError(\"Invalid match id\");\n      return;\n    }\n    setError(\"\");\n    setMatchId(id);\n  };\n\n  const handleChange = async (row: number, col: number, value: string) => {\n    if (!isMonad) {\n      setError(\"Switch to Monad Testnet to submit moves\");\n      return;\n    }\n    if (!canSubmit) {\n      setError(\"Create or load a match first\");\n      return;\n    }\n    if (givens[row][col] !== 0) {\n      setError(\"Cannot change a fixed cell\");\n      return;\n    }\n    setError(\"\");\n    setStatus(\"\");\n\n    const digit = value === \"\" ? 0 : Number(value);\n    if (Number.isNaN(digit) || digit < 0 || digit > 9) return;\n\n    setSelectedValue(digit);\n    setSelectedCell({ row, col });\n\n    const key: PendingKey = `${row}-${col}`;\n    setPendingCells((prev) => new Set(prev).add(key));\n\n    try {\n      setStatus(\"Submitting move...\");\n      if (useRelayer && relayerSession && address) {\n        const response = await fetch(\"/api/relay\", {\n          method: \"POST\",\n          headers: { \"Content-Type\": \"application/json\" },\n          body: JSON.stringify({\n            matchId,\n            row,\n            col,\n            value: digit,\n            player: address,\n            expiresAt: relayerSession.expiresAt,\n            signature: relayerSession.signature\n          })\n        });\n        let json: any = null;\n        const contentType = response.headers.get(\"content-type\") || \"\";\n        if (contentType.includes(\"application/json\")) {\n          json = await response.json();\n        }\n        if (!response.ok) {\n          const fallback = json?.error || `Relayer failed (${response.status})`;\n          throw new Error(fallback);\n        }\n        if (json?.hash) {\n          setTxHash(json.hash as `0x${string}`);\n        }\n        setStatus(\"Move relayed. Waiting for confirmation...\");\n      } else {\n        const hash = await writeContractAsync({\n          abi: sudokuArenaAbi,\n          address: arenaAddress!,\n          chainId: monadTestnet.id,\n          functionName: \"submitMove\",\n          args: [BigInt(matchId), row, col, digit]\n        });\n        setTxHash(hash);\n        setStatus(\"Move submitted. Waiting for confirmation...\");\n      }\n\n      setGrid((prev) => {\n        const next = prev.map((r) => [...r]);\n        next[row][col] = digit;\n        return next;\n      });\n    } catch (err: any) {\n      setError(err?.shortMessage || err?.message || \"Move failed\");\n    } finally {\n      setPendingCells((prev) => {\n        const next = new Set(prev);\n        next.delete(key);\n        return next;\n      });\n    }\n  };\n\n  const handleEnableRelayer = async () => {\n    if (!address) {\n      setError(\"Connect your wallet first\");\n      return;\n    }\n    const expiresAt = Date.now() + 1000 * 60 * 60 * 6;\n    const message = `Arcade2 Relayer Session\naddress:${address}\nexpiresAt:${expiresAt}\nchainId:${monadTestnet.id}`;\n    try {\n      const signature = await signMessageAsync({ message });\n      const session = { expiresAt, signature };\n      localStorage.setItem(\"arcade2-relayer-session\", JSON.stringify(session));\n      setRelayerSession(session);\n      setError(\"\");\n      setStatus(\"Relayer session enabled\");\n    } catch (err: any) {\n      setError(err?.shortMessage || err?.message || \"Relayer auth failed\");\n    }\n  };\n\n  return (\n    <section className=\"card\">\n      <div className=\"row\">\n        <h2>Sudoku (On-chain moves)</h2>\n        <span className=\"muted\">\n          {matchId ? `Match #${matchId}` : \"No match loaded\"}\n        </span>\n      </div>\n\n      {!arenaAddress ? (\n        <p className=\"error\">Missing NEXT_PUBLIC_SUDOKU_ARENA_ADDRESS</p>\n      ) : null}\n      {!mounted ? (\n        <p className=\"muted\">Loading match controls...</p>\n      ) : null}\n      {mounted && !isMonad && arenaAddress ? (\n        <div className=\"row\">\n          <p className=\"error\">Wrong network. Switch to Monad Testnet.</p>\n          <button className=\"secondary\" onClick={() => switchChain({ chainId: monadTestnet.id })}>\n            Switch Network\n          </button>\n        </div>\n      ) : null}\n\n      <div className=\"row\">\n        <button\n          onClick={handleCreatePve}\n          disabled={!mounted || !address || !arenaAddress || !isMonad}\n        >\n          Create PvE Match\n        </button>\n        <div className=\"row\">\n          <input\n            type=\"number\"\n            min=\"1\"\n            step=\"1\"\n            value={matchIdInput}\n            onChange={(event) => setMatchIdInput(event.target.value)}\n            disabled={!mounted}\n          />\n          <button className=\"secondary\" onClick={handleLoadMatch} disabled={!mounted}>\n            Load Match\n          </button>\n        </div>\n      </div>\n\n      <div className=\"row\">\n        <label className=\"row muted\">\n          <input\n            type=\"checkbox\"\n            checked={useRelayer}\n            onChange={(event) => setUseRelayer(event.target.checked)}\n            disabled={!mounted}\n          />\n          Use relayer (fewer approvals)\n        </label>\n        {useRelayer ? (\n          <button\n            className=\"secondary\"\n            onClick={handleEnableRelayer}\n            disabled={!mounted || !address}\n          >\n            {relayerSession ? \"Relayer enabled\" : \"Enable relayer\"}\n          </button>\n        ) : null}\n      </div>\n\n      <div className=\"sudoku-grid\">\n        {grid.map((row, r) =>\n          row.map((value, c) => {\n            const key: PendingKey = `${r}-${c}`;\n            const isPending = pendingCells.has(key);\n            const isFixed = givens[r][c] !== 0;\n            const isHighlighted = selectedValue > 0 && value === selectedValue;\n            const isRowCol =\n              selectedCell && (selectedCell.row === r || selectedCell.col === c);\n            const isBox =\n              selectedCell &&\n              Math.floor(selectedCell.row / 3) === Math.floor(r / 3) &&\n              Math.floor(selectedCell.col / 3) === Math.floor(c / 3);\n            const isInvalid = invalidCells.has(key);\n            return (\n              <input\n                key={key}\n                className={`sudoku-cell ${isPending ? \"pending\" : \"\"} ${\n                  isFixed ? \"fixed\" : \"\"\n                } ${isHighlighted ? \"highlight\" : \"\"} ${\n                  isRowCol ? \"rowcol\" : \"\"\n                } ${isBox ? \"box\" : \"\"} ${isInvalid ? \"invalid\" : \"\"}`}\n                inputMode=\"numeric\"\n                maxLength={1}\n                value={value === 0 ? \"\" : value}\n                onChange={(event) => handleChange(r, c, event.target.value)}\n                onFocus={() => {\n                  setSelectedValue(value);\n                  setSelectedCell({ row: r, col: c });\n                }}\n                onClick={() => {\n                  setSelectedValue(value);\n                  setSelectedCell({ row: r, col: c });\n                }}\n                disabled={!canSubmit || isConfirming || isFixed}\n                style={{\n                  borderRightWidth: c % 3 === 2 ? 2 : 1,\n                  borderBottomWidth: r % 3 === 2 ? 2 : 1,\n                  borderLeftWidth: c % 3 === 0 ? 2 : 1,\n                  borderTopWidth: r % 3 === 0 ? 2 : 1,\n                  borderRightColor: c % 3 === 2 ? \"#4b4b5a\" : undefined,\n                  borderBottomColor: r % 3 === 2 ? \"#4b4b5a\" : undefined,\n                  borderLeftColor: c % 3 === 0 ? \"#4b4b5a\" : undefined,\n                  borderTopColor: r % 3 === 0 ? \"#4b4b5a\" : undefined\n                }}\n              />\n            );\n          })\n        )}\n      </div>\n\n      {isComplete && !isConfirmed ? (\n        <p className=\"success\">Solved! Waiting for chain confirmation.</p>\n      ) : null}\n      {isConfirmed ? <p className=\"success\">Solved! On-chain moves confirmed.</p> : null}\n      {status ? <p className=\"muted\">{status}</p> : null}\n      {error ? <p className=\"error\">{error}</p> : null}\n      <p className=\"muted\">\n        Each number entry submits a transaction (including clears).\n      </p>\n    </section>\n  );\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1608, "column": 0}, "map": {"version":3,"sources":["file:///Users/jackmccordic/Desktop/Vibes/Arcade2/src/components/CreateChallengeButton.tsx"],"sourcesContent":["\"use client\";\n\ntype Props = {\n  onClick: () => void;\n};\n\nexport default function CreateChallengeButton({ onClick }: Props) {\n  return (\n    <button className=\"secondary\" onClick={onClick}>\n      Create Challenge\n    </button>\n  );\n}\n"],"names":[],"mappings":";;;;;AAAA;;AAMe,SAAS,sBAAsB,EAAE,OAAO,EAAS;IAC9D,qBACE,kQAAC;QAAO,WAAU;QAAY,SAAS;kBAAS;;;;;;AAIpD"}},
    {"offset": {"line": 1630, "column": 0}, "map": {"version":3,"sources":["file:///Users/jackmccordic/Desktop/Vibes/Arcade2/src/components/CreateChallengeModal.tsx"],"sourcesContent":["\"use client\";\n\nimport { useEffect, useMemo, useState } from \"react\";\nimport { Address, decodeEventLog, keccak256, parseEther, stringToHex } from \"viem\";\nimport { useAccount, useChainId, usePublicClient, useWaitForTransactionReceipt, useWriteContract } from \"wagmi\";\nimport { arcadeEscrowAbi, getArcadeEscrowAddress } from \"../lib/contracts/arcadeEscrow\";\nimport { sudokuArenaAbi, getSudokuArenaAddress } from \"../lib/contracts/sudokuArena\";\nimport { monadTestnet } from \"../lib/wagmi\";\n\nconst MIN_WAGER = 1;\n\ntype Props = {\n  isOpen: boolean;\n  onClose: () => void;\n};\n\nexport default function CreateChallengeModal({ isOpen, onClose }: Props) {\n  const { address, isConnected } = useAccount();\n  const chainId = useChainId();\n  const publicClient = usePublicClient();\n  const [opponentInput, setOpponentInput] = useState(\"\");\n  const [gameId, setGameId] = useState(1);\n  const [wager, setWager] = useState(\"1\");\n  const [acceptMinutes, setAcceptMinutes] = useState(\"30\");\n  const [resolveMinutes, setResolveMinutes] = useState(\"60\");\n  const [status, setStatus] = useState(\"\");\n  const [error, setError] = useState(\"\");\n  const [txHash, setTxHash] = useState<`0x${string}` | null>(null);\n\n  const { writeContractAsync } = useWriteContract();\n  const { isLoading: isConfirming, isSuccess } = useWaitForTransactionReceipt({\n    hash: txHash || undefined\n  });\n\n  const isMonad = chainId === monadTestnet.id;\n  const escrowAddress = getArcadeEscrowAddress();\n  const arenaAddress = getSudokuArenaAddress();\n\n  useEffect(() => {\n    if (!isOpen) {\n      setStatus(\"\");\n      setError(\"\");\n      setTxHash(null);\n    }\n  }, [isOpen]);\n\n  useEffect(() => {\n    if (!isSuccess) return;\n    setStatus(\"Challenge created!\");\n    const timer = setTimeout(() => {\n      onClose();\n    }, 800);\n    return () => clearTimeout(timer);\n  }, [isSuccess, onClose]);\n\n  const canSubmit = useMemo(() => {\n    return Boolean(isConnected && address && isMonad && escrowAddress);\n  }, [isConnected, address, isMonad, escrowAddress]);\n\n  if (!isOpen) return null;\n\n  const resolveOpponent = async (): Promise<`0x${string}`> => {\n    const raw = opponentInput.trim();\n    if (!raw) {\n      throw new Error(\"Opponent is required\");\n    }\n    if (!isAddress(raw)) {\n      throw new Error(\"Opponent must be a 0x address\");\n    }\n    return raw as `0x${string}`;\n  };\n\n  const handleCreate = async () => {\n    if (!address) return;\n    setError(\"\");\n    setStatus(\"\");\n    setTxHash(null);\n\n    if (!escrowAddress || !arenaAddress) {\n      setError(\"Missing contract address\");\n      return;\n    }\n    if (!isConnected) {\n      setError(\"Connect your wallet first\");\n      return;\n    }\n    if (!isMonad) {\n      setError(\"Wrong network. Switch to Monad Testnet.\");\n      return;\n    }\n\n    let opponentAddress: `0x${string}`;\n    try {\n      setStatus(\"Resolving opponent...\");\n      opponentAddress = await resolveOpponent();\n    } catch (err: any) {\n      setError(err?.message || \"Failed to resolve opponent\");\n      setStatus(\"\");\n      return;\n    }\n\n    if (opponentAddress.toLowerCase() === address.toLowerCase()) {\n      setError(\"Opponent cannot be your own address\");\n      setStatus(\"\");\n      return;\n    }\n\n    let wagerWei: bigint;\n    try {\n      wagerWei = parseEther(wager);\n    } catch {\n      setError(\"Invalid wager\");\n      setStatus(\"\");\n      return;\n    }\n    if (wagerWei < parseEther(String(MIN_WAGER))) {\n      setError(`Wager must be at least ${MIN_WAGER} MON`);\n      setStatus(\"\");\n      return;\n    }\n\n    const nowSeconds = Math.floor(Date.now() / 1000);\n    const acceptBy = nowSeconds + Number(acceptMinutes) * 60;\n    const resolveBy = acceptBy + Number(resolveMinutes) * 60;\n    if (!Number.isFinite(acceptBy) || acceptBy <= nowSeconds) {\n      setError(\"Accept window must be in the future\");\n      setStatus(\"\");\n      return;\n    }\n    if (!Number.isFinite(resolveBy) || resolveBy <= acceptBy) {\n      setError(\"Resolve window must be after accept window\");\n      setStatus(\"\");\n      return;\n    }\n\n    const meta = {\n      gameId,\n      wager: wagerWei.toString(),\n      createdBy: address,\n      opponent: opponentAddress,\n      createdAtMs: Date.now()\n    };\n    const metaHash = keccak256(stringToHex(JSON.stringify(meta)));\n\n    try {\n      setStatus(\"Sending transaction...\");\n      const hash = await writeContractAsync({\n        abi: arcadeEscrowAbi,\n        address: escrowAddress,\n        functionName: \"createChallenge\",\n        args: [\n          opponentAddress,\n          gameId,\n          BigInt(acceptBy),\n          BigInt(resolveBy),\n          metaHash\n        ],\n        value: wagerWei\n      });\n      setTxHash(hash);\n      setStatus(\"Challenge created. Linking PvP match...\");\n\n      const receipt = await publicClient?.waitForTransactionReceipt({ hash });\n      const log = receipt?.logs.find((l) => l.address.toLowerCase() === escrowAddress.toLowerCase());\n      if (!log) {\n        setStatus(\"Challenge created. Match id not found.\");\n        return;\n      }\n      const decoded = decodeEventLog({\n        abi: arcadeEscrowAbi,\n        data: log.data,\n        topics: log.topics\n      });\n      if (decoded.eventName !== \"ChallengeCreated\") {\n        setStatus(\"Challenge created. Match id missing.\");\n        return;\n      }\n\n      const matchId = decoded.args.matchId as bigint;\n      await writeContractAsync({\n        abi: sudokuArenaAbi,\n        address: arenaAddress,\n        functionName: \"createPvpMatch\",\n        args: [\n          matchId,\n          opponentAddress,\n          gameId,\n          BigInt(acceptBy),\n          BigInt(resolveBy)\n        ]\n      });\n      setStatus(`PvP match linked (#${matchId.toString()}).`);\n    } catch (err: any) {\n      setError(err?.shortMessage || err?.message || \"Transaction failed\");\n      setStatus(\"\");\n    }\n  };\n\n  const handleClose = () => {\n    if (isConfirming) return;\n    onClose();\n  };\n\n  return (\n    <div className=\"modal-overlay\">\n      <div className=\"modal\">\n        <div className=\"modal-header\">\n          <h2>Create Challenge</h2>\n          <button className=\"secondary\" onClick={handleClose}>\n            Close\n          </button>\n        </div>\n\n        {!escrowAddress ? (\n          <p className=\"error\">Missing NEXT_PUBLIC_ARCADE_ESCROW_ADDRESS</p>\n        ) : null}\n\n        <label className=\"field\">\n          <span>Opponent</span>\n          <input\n            type=\"text\"\n            placeholder=\"0x...\"\n            value={opponentInput}\n            onChange={(event) => setOpponentInput(event.target.value)}\n          />\n        </label>\n\n        <label className=\"field\">\n          <span>Game</span>\n          <select value={gameId} onChange={(event) => setGameId(Number(event.target.value))}>\n            <option value={1}>Sudoku</option>\n          </select>\n        </label>\n\n        <label className=\"field\">\n          <span>Wager (MON)</span>\n          <input\n            type=\"number\"\n            min={MIN_WAGER}\n            step=\"0.01\"\n            value={wager}\n            onChange={(event) => setWager(event.target.value)}\n          />\n        </label>\n\n        <div className=\"row\">\n          <label className=\"field\">\n            <span>Accept window (minutes)</span>\n            <input\n              type=\"number\"\n              min=\"1\"\n              step=\"1\"\n              value={acceptMinutes}\n              onChange={(event) => setAcceptMinutes(event.target.value)}\n            />\n          </label>\n          <label className=\"field\">\n            <span>Resolve window (minutes)</span>\n            <input\n              type=\"number\"\n              min=\"1\"\n              step=\"1\"\n              value={resolveMinutes}\n              onChange={(event) => setResolveMinutes(event.target.value)}\n            />\n          </label>\n        </div>\n\n        <div className=\"row\">\n          <button onClick={handleCreate} disabled={!canSubmit || isConfirming}>\n            Create challenge\n          </button>\n          {status ? <span className=\"muted\">{status}</span> : null}\n        </div>\n\n        {isConfirming ? <p className=\"muted\">Waiting for confirmation...</p> : null}\n        {error ? <p className=\"error\">{error}</p> : null}\n\n        <p className=\"muted\">Minimum wager: {MIN_WAGER} MON.</p>\n      </div>\n    </div>\n  );\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2093, "column": 0}, "map": {"version":3,"sources":["file:///Users/jackmccordic/Desktop/Vibes/Arcade2/src/components/RefundPanel.tsx"],"sourcesContent":["\"use client\";\n\nimport { useState } from \"react\";\nimport { useAccount, useChainId, useWaitForTransactionReceipt, useWriteContract } from \"wagmi\";\nimport { arcadeEscrowAbi, getArcadeEscrowAddress } from \"../lib/contracts/arcadeEscrow\";\nimport { monadTestnet } from \"../lib/wagmi\";\n\nexport default function RefundPanel() {\n  const { isConnected } = useAccount();\n  const chainId = useChainId();\n  const [matchId, setMatchId] = useState(\"1\");\n  const [status, setStatus] = useState(\"\");\n  const [error, setError] = useState(\"\");\n  const [txHash, setTxHash] = useState<`0x${string}` | null>(null);\n\n  const { writeContractAsync } = useWriteContract();\n  const { isLoading: isConfirming, isSuccess } = useWaitForTransactionReceipt({\n    hash: txHash || undefined\n  });\n\n  const escrowAddress = getArcadeEscrowAddress();\n  const isMonad = chainId === monadTestnet.id;\n\n  const handleRefund = async () => {\n    setError(\"\");\n    setStatus(\"\");\n    setTxHash(null);\n\n    if (!escrowAddress) {\n      setError(\"Missing contract address\");\n      return;\n    }\n    if (!isConnected) {\n      setError(\"Connect your wallet first\");\n      return;\n    }\n    if (!isMonad) {\n      setError(\"Wrong network. Switch to Monad Testnet.\");\n      return;\n    }\n\n    const id = Number(matchId);\n    if (!Number.isInteger(id) || id <= 0) {\n      setError(\"Invalid match id\");\n      return;\n    }\n\n    try {\n      setStatus(\"Submitting refund...\");\n      const hash = await writeContractAsync({\n        abi: arcadeEscrowAbi,\n        address: escrowAddress,\n        functionName: \"refund\",\n        args: [BigInt(id)]\n      });\n      setTxHash(hash);\n      setStatus(\"Refund submitted\");\n    } catch (err: any) {\n      setError(err?.shortMessage || err?.message || \"Refund failed\");\n      setStatus(\"\");\n    }\n  };\n\n  return (\n    <section className=\"card\">\n      <h3>Refund Challenge</h3>\n      <p className=\"muted\">Creator-only refunds after accept or resolve deadline.</p>\n      <label className=\"field\">\n        <span>Match ID</span>\n        <input\n          type=\"number\"\n          min=\"1\"\n          step=\"1\"\n          value={matchId}\n          onChange={(event) => setMatchId(event.target.value)}\n        />\n      </label>\n      <div className=\"row\">\n        <button onClick={handleRefund} disabled={isConfirming}>\n          Request refund\n        </button>\n        {status ? <span className=\"muted\">{status}</span> : null}\n      </div>\n      {isSuccess ? <p className=\"success\">Refund confirmed</p> : null}\n      {error ? <p className=\"error\">{error}</p> : null}\n    </section>\n  );\n}\n"],"names":[],"mappings":";;;;;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AALA;;;;;;AAOe,SAAS;IACtB,MAAM,EAAE,WAAW,EAAE,GAAG,IAAA,+OAAU;IAClC,MAAM,UAAU,IAAA,6LAAU;IAC1B,MAAM,CAAC,SAAS,WAAW,GAAG,IAAA,qOAAQ,EAAC;IACvC,MAAM,CAAC,QAAQ,UAAU,GAAG,IAAA,qOAAQ,EAAC;IACrC,MAAM,CAAC,OAAO,SAAS,GAAG,IAAA,qOAAQ,EAAC;IACnC,MAAM,CAAC,QAAQ,UAAU,GAAG,IAAA,qOAAQ,EAAuB;IAE3D,MAAM,EAAE,kBAAkB,EAAE,GAAG,IAAA,yMAAgB;IAC/C,MAAM,EAAE,WAAW,YAAY,EAAE,SAAS,EAAE,GAAG,IAAA,iOAA4B,EAAC;QAC1E,MAAM,UAAU;IAClB;IAEA,MAAM,gBAAgB,IAAA,qLAAsB;IAC5C,MAAM,UAAU,YAAY,uJAAY,CAAC,EAAE;IAE3C,MAAM,eAAe;QACnB,SAAS;QACT,UAAU;QACV,UAAU;QAEV,IAAI,CAAC,eAAe;YAClB,SAAS;YACT;QACF;QACA,IAAI,CAAC,aAAa;YAChB,SAAS;YACT;QACF;QACA,IAAI,CAAC,SAAS;YACZ,SAAS;YACT;QACF;QAEA,MAAM,KAAK,OAAO;QAClB,IAAI,CAAC,OAAO,SAAS,CAAC,OAAO,MAAM,GAAG;YACpC,SAAS;YACT;QACF;QAEA,IAAI;YACF,UAAU;YACV,MAAM,OAAO,MAAM,mBAAmB;gBACpC,KAAK,8KAAe;gBACpB,SAAS;gBACT,cAAc;gBACd,MAAM;oBAAC,OAAO;iBAAI;YACpB;YACA,UAAU;YACV,UAAU;QACZ,EAAE,OAAO,KAAU;YACjB,SAAS,KAAK,gBAAgB,KAAK,WAAW;YAC9C,UAAU;QACZ;IACF;IAEA,qBACE,kQAAC;QAAQ,WAAU;;0BACjB,kQAAC;0BAAG;;;;;;0BACJ,kQAAC;gBAAE,WAAU;0BAAQ;;;;;;0BACrB,kQAAC;gBAAM,WAAU;;kCACf,kQAAC;kCAAK;;;;;;kCACN,kQAAC;wBACC,MAAK;wBACL,KAAI;wBACJ,MAAK;wBACL,OAAO;wBACP,UAAU,CAAC,QAAU,WAAW,MAAM,MAAM,CAAC,KAAK;;;;;;;;;;;;0BAGtD,kQAAC;gBAAI,WAAU;;kCACb,kQAAC;wBAAO,SAAS;wBAAc,UAAU;kCAAc;;;;;;oBAGtD,uBAAS,kQAAC;wBAAK,WAAU;kCAAS;;;;;+BAAiB;;;;;;;YAErD,0BAAY,kQAAC;gBAAE,WAAU;0BAAU;;;;;uBAAuB;YAC1D,sBAAQ,kQAAC;gBAAE,WAAU;0BAAS;;;;;uBAAa;;;;;;;AAGlD"}},
    {"offset": {"line": 2260, "column": 0}, "map": {"version":3,"sources":["file:///Users/jackmccordic/Desktop/Vibes/Arcade2/src/app/page.tsx"],"sourcesContent":["\"use client\";\n\nimport WalletStatus from \"../components/WalletStatus\";\nimport PendingChallenges from \"../components/PendingChallenges\";\nimport SudokuGame from \"../components/SudokuGame\";\nimport CreateChallengeButton from \"../components/CreateChallengeButton\";\nimport CreateChallengeModal from \"../components/CreateChallengeModal\";\nimport RefundPanel from \"../components/RefundPanel\";\nimport { useState } from \"react\";\n\nexport default function HomePage() {\n  const [isModalOpen, setIsModalOpen] = useState(false);\n\n  return (\n    <main className=\"container grid\">\n      <section className=\"stack\">\n        <header className=\"card hero-card\">\n          <h1>Onchain Arcade</h1>\n          <p className=\"muted\">Connect your wallet to see incoming wagers.</p>\n        </header>\n        <WalletStatus />\n        <CreateChallengeButton onClick={() => setIsModalOpen(true)} />\n        <CreateChallengeModal isOpen={isModalOpen} onClose={() => setIsModalOpen(false)} />\n        <SudokuGame />\n        <RefundPanel />\n      </section>\n      <PendingChallenges />\n    </main>\n  );\n}\n"],"names":[],"mappings":";;;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;;;;;;;;;AAUe,SAAS;IACtB,MAAM,CAAC,aAAa,eAAe,GAAG,IAAA,qOAAQ,EAAC;IAE/C,qBACE,kQAAC;QAAK,WAAU;;0BACd,kQAAC;gBAAQ,WAAU;;kCACjB,kQAAC;wBAAO,WAAU;;0CAChB,kQAAC;0CAAG;;;;;;0CACJ,kQAAC;gCAAE,WAAU;0CAAQ;;;;;;;;;;;;kCAEvB,kQAAC,iKAAY;;;;;kCACb,kQAAC,0KAAqB;wBAAC,SAAS,IAAM,eAAe;;;;;;kCACrD,kQAAC,yKAAoB;wBAAC,QAAQ;wBAAa,SAAS,IAAM,eAAe;;;;;;kCACzE,kQAAC,+JAAU;;;;;kCACX,kQAAC,gKAAW;;;;;;;;;;;0BAEd,kQAAC,sKAAiB;;;;;;;;;;;AAGxB"}}]
}